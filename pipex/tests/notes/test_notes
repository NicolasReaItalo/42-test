

NOTES PIPEX







l faut d'abord que tu comprennes ce qu'est un SIGPIPE.
En clair, tu as la commande A qui va √©crire dans un pipe, et la commande B qui va lire ce pipe en m√™me temps. Pour certaines raisons, il est possible que la commande B se termine avant la A, et ferme son c√¥t√© du pipe. Probl√®me, la commande A √©tait en train d'√©crire dedans, et donc crash. C'est par example le cas avec /dev/stdin < cat | ls > /dev/stdout, o√π ls va se terminer avant le cat, qui est bloquant. Il y a aussi le cas o√π tu as une commande B qui n'existe pas, et va donc renvoyer une erreur bien plus rapidement que la commande A ne puisse s'executer. (modifi√©)

2
[17:31]
Dans ces cas-ci, oui, il est normal de leak, et non, tu ne dois pas les g√©rer. V√©rifie bien que ce sont des leaks li√©es aux commandes, et non √† ton programme cela-dit.

@apayen (Alexis)
Dans ces cas-ci, oui, il est normal de leak, et non, tu ne dois pas les g√©rer. V√©rifie bien que ce sont des leaks li√©es aux commandes, et non √† ton programme cela-dit.
./p









Valgrind

valgrind --log-file="filename et n hesite pas a
aussi mettre --track-fds=yes --trace-children=yes pour le projet on sait jamais üôÇ


valgrind --log-file="filename"  --track-fds=yes --trace-children=yes



https://stackoverflow.com/questions/63474134/how-to-free-memory-of-char-arrays-after-passing-them-to-exec-family-of-functi

recuperer les arguments

si - de 4 arguments
	return

parse arguments
premier = infile
deuxieme = cmd1
....
dernier outfile




out_file  : O_CREATE | O_TRUNC | O_WRONLYp
Verifier les permissions, si pas un repertoire, les liens symboliques...





‚ûú  pipex git:(master) ‚úó ./pipex oo "/usr/bin/ls -l" "./test.sh" "/usr/bin/cat -n" test_outfile
./test.sh: Permission denied

‚ûú  pipex git:(master) ‚úó ./pipex oo "/usr/bin/ls -l" "./test.s" "/usr/bin/cat -n" test_outfile
./test.s: No such file or directory



/dev/stdin cat ls /dev/stdout, pour v√©rifier la connexion des pipes/waits qui doit faire un sigpipe.
time in "sleep 5" "sleep 5" out, pour v√©rifier que tu lances les commandes "en m√™me temps". (Le temps devrait √™tre d'environ 5s, pas 10.)
fichier in sans droit ou inexistant, et v√©rifier que la premi√®re commande n'est pas execut√©. (Idem pour out et la derni√®re commande)
Commande sans droit ou inexistante en premi√®re et/ou deuxi√®me.
in /usr/bin/ls /usr/bin/cat out, pour v√©rifier la recherche absolue.
cp /usr/bin/ls ./; mv ls lsa; in ./lsa cat out, pour v√©rifier la recherche relatif. (Tu peux aussi mettre le lsa dans un sous-dossier de ton pipex, et le lancer via dossier/lsa)
Bien v√©rifier les leaks (y compris les fds) dans tous les cas au dessus, et en cas de fail d'execve. (modifi√©)
[21:26]
Je me rappelle pas d'autres cas pr√©cis. Si tu passe ceux-l√†, c'est que tu as d√©j√† une bonne base, avec une connection de pipe sans probl√®me et un parsing correct.
[21:28]
Ah, et si j'√©tais ton correcteur, je v√©rifierais aussi que tu ne fasse pas d'open sur un fichier apr√®s avoir utilis√© un access dessus (comme √©crit dans le man). (modifi√©)
[21:29]
Oh, et j'ai oubli√© les zombies. Mais si tu en as, tu as des probl√®mes avec les waits, donc √ßa se remarquera sur bien plus de tests. (modifi√©)

2






















****************************

Une erreur dans une des commandes ne va pas interrompre les autres.
ex :
< test_infile grepo a1 | wc -l > test_outfile
==> wc s'execute qd meme avec et nvoie 0 car il n'a rien recu de stdin

****************************
‚ûú  pipex git:(master) ‚úó chmod 0 test_outfile
‚ûú  pipex git:(master) ‚úó < test_infile grep a1 | wc -l > test_outfile
zsh: permission denied: test_outfile

*****************************
‚ûú  pipex git:(master) ‚úó chmod 0 test_infile
‚ûú  pipex git:(master) ‚úó < test_infile grep a1 | wc -l > test_outfile
zsh: permission denied: test_infile


****************************
‚ûú  pipex git:(master) ‚úó < test_infile grep a1 | wc -l > test_fichier_inexistant
Va creer le fichier test_fichier_inexistant



****************************
‚ûú  pipex git:(master) ‚úó < test_fichier_inexistant grep a1 | wc -l > test_outfile
zsh: no such file or directory: test_fichier_inexistant
‚ûú  pipex git:(master) ‚úó

****************************
‚ûú  pipex git:(master) ‚úó mkdir test_dir
‚ûú  pipex git:(master) ‚úó < test_infile grep a1 | wc -l > test_dir
zsh: is a directory: test_dir


Idee avec bonus

Verification infile si existant et autorisation lecture
Verification outfile si existant(sinon O_CREATE) et autorisation ecriture
Prendre en compte le cas ou infile et outfile sont les meme !

Quand erreur dans une commande
(

	ft_get_path : construit la commande complete a partir de la variable PATH

	ft_getenv("PATH")

	Message d'erreur sur STDERR
	commande inexistante -> Affichage "zsh: command not found: heafrwqferwd"
	mauvais arguments -> Message d'erreur de la commande

On envoie 0 dans stdout et on continue la chaine de pipe
)

les erreurs peuvent se succeder : AFFICHAGE SUR STDERR
head: invalid option -- 'p'
Try 'head --help' for more information.
zsh: command not found: wco



< test_infile grep a1 | head -po 1 2>stderr |wco -l 2>stderr | cat -e > test_outfile

cat stderr

‚ûú  pipex git:(master) ‚úó cat stderr
zsh: command not found: wco
Try 'head --help' for more information.




‚ûú  pipex git:(master) ‚úó  ping -c 5 google.com | cat -jk
cat: invalid option -- 'j'
Try 'cat --help' for more information.
‚ûú  pipex git:(master) ‚úó  ping -c 5 google.com | cato -e
zsh: command not found: cato
‚ûú  pipex git:(master) ‚úó










https://www.baeldung.com/linux/piped-commands-order

In this article, we discussed the concurrent execution and the execution order of processes in a pipeline.

First, we learned about pipes. Despite some limitations, pipes are one of the most widely used IPC mechanisms. We discussed that processes in a pipeline run concurrently. We also saw that the operating system may not run the commands in their specified order in the pipeline. The order depends on the scheduling by the operating system.

Then, we looked at two examples that showed the concurrent operation of piped processes and their execution order. We saw that the order may not always be the same in each execution.



UN process parent qui va se charger de la derniere commande du pipe.

pour chaque commande un fork depuis le main process
un double tableau de pipe fd[nb_commande][2]





SYNOPSIS
#include <unistd.h>

int execve(const char *pathname, char *const argv[],
			char *const envp[]);

DESCRIPTION
execve() executes the program referred to by pathname.  This causes the program that is currently being run by the
calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized and unini‚Äê
tialized) data segments.

pathname must be either a binary executable, or a script starting with a line of the form:

	#!interpreter [optional-arg]

For details of the latter case, see "Interpreter scripts" below.

argv  is  an array of pointers to strings passed to the new program as its command-line arguments.  By convention,
the first of these strings (i.e., argv[0]) should contain the filename associated with the  file  being  executed.
The argv array must be terminated by a NULL pointer.  (Thus, in the new program, argv[argc] will be NULL.)





















